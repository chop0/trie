package trie;import java.util.*;import java.util.concurrent.atomic.AtomicBoolean;record TrieImpl(AtomicBoolean isEndOfWord, TrieImpl parent, Optional<Character> character,                SortedSet<TrieImpl> children) implements Trie {    TrieImpl(TrieImpl parent, char character) {        this(new AtomicBoolean(), parent, Optional.of(character), new TreeSet<>());    }    @Override    public void insertWord(String word) {        insertWord(0, word);    }    @Override    public boolean containsWord(String word) {        return containsWord(0, word);    }    @Override    public Optional<TrieImpl> getSubtrie(String word) {        return getSubtrie(0, word);    }    // didn't feel like making this method recursive    @Override    public boolean removeWord(String word) {        if (word.isEmpty() || !containsWord(word))            return false;        TrieImpl endNode = getSubtrie(word).get();        endNode.isEndOfWord.set(false);        while (endNode.isLeaf() && !endNode.isEndOfWord.get()) {            endNode.parent.children().remove(endNode);            if (!endNode.parent.isRoot())                endNode = endNode.parent;            else                break;        }        return true;    }    @Override    public ArrayList<String> getAllWords() {        var list = new ArrayList<String>();        getAllWords("", list);        return list;    }    private void getAllWords(String current, ArrayList<String> words) {        String stringIncludingCurrent = current + character.map(String::valueOf).orElse("");        if (isEndOfWord.get())            words.add(stringIncludingCurrent);        for (TrieImpl child : children())            child.getAllWords(stringIncludingCurrent, words);    }    private Optional<TrieImpl> getTrieOfCharacter(char character) {        var view = children().tailSet(new TrieImpl(null, character));        if (view.isEmpty())            return Optional.empty();        else            return Optional.of(view.first());    }    private void insertWord(int i, String word) {        if (i >= word.length())            return; // stop condition        var characterToAdd = word.charAt(i);        var isEndOfWord = ++i >= word.length();        var existingTrie = getTrieOfCharacter(characterToAdd).orElseGet(() -> {            var newTrie = new TrieImpl(this, characterToAdd);            children().add(newTrie);            return newTrie;        });        existingTrie.insertWord(i, word);        existingTrie.isEndOfWord.compareAndSet(false, isEndOfWord);    }    public boolean containsWord(int i, String word) {        if (i >= word.length())            return isRoot() || isEndOfWord.get();        return getTrieOfCharacter(word.charAt(i)).map(n -> n.containsWord(i + 1, word)).orElse(false);    }    private Optional<TrieImpl> getSubtrie(int i, String word) {        if (i >= word.length())            return Optional.of(this);        return getTrieOfCharacter(word.charAt(i)).flatMap(n -> n.getSubtrie(i + 1, word));    }    public int compareTo(TrieImpl other) {        return this.character.flatMap(thisChar -> other.character.map(otherChar -> Character.compare(thisChar,                otherChar))).orElse(Integer.compare(this.hashCode(), other.hashCode()));    }    @Override    public boolean isLeaf() {        return children().isEmpty();    }    @Override    public boolean isRoot() {        return character.isEmpty();    }    private void toString(int indent, StringBuilder stringBuilder) {        if (!isRoot())            stringBuilder.append(character.get());        for (var child : children) {            if (isEndOfWord.get()) {                stringBuilder.append("\n");                if (!children.isEmpty())                    stringBuilder.append("\t".repeat(indent)).append("|-");                child.toString(indent + 1, stringBuilder);            }            else                child.toString(indent, stringBuilder);        }    }    @Override    public boolean equals(Object o) {        if (this == o)            return true;        if (o == null || getClass() != o.getClass())            return false;        TrieImpl datum = (TrieImpl) o;        return character.equals(datum.character);    }    @Override    public int hashCode() {        return Objects.hash(character);    }    public String toString() {        var builder = new StringBuilder();        toString(1, builder);        return builder.toString();    }}